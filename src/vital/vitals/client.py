# This file was auto-generated by Fern from our API Definition.

from ..core.client_wrapper import SyncClientWrapper
import typing
from ..core.request_options import RequestOptions
from ..types.grouped_basal_body_temperature_response import GroupedBasalBodyTemperatureResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.grouped_handwashing_response import GroupedHandwashingResponse
from ..types.grouped_daylight_exposure_response import GroupedDaylightExposureResponse
from ..types.grouped_uv_exposure_response import GroupedUvExposureResponse
from ..types.grouped_fall_response import GroupedFallResponse
from ..types.grouped_inhaler_usage_response import GroupedInhalerUsageResponse
from ..types.grouped_peak_expiratory_flow_rate_response import GroupedPeakExpiratoryFlowRateResponse
from ..types.grouped_forced_vital_capacity_response import GroupedForcedVitalCapacityResponse
from ..types.grouped_forced_expiratory_volume_1_response import GroupedForcedExpiratoryVolume1Response
from ..types.grouped_wheelchair_push_response import GroupedWheelchairPushResponse
from ..types.grouped_sleep_breathing_disturbance_response import GroupedSleepBreathingDisturbanceResponse
from ..types.grouped_sleep_apnea_alert_response import GroupedSleepApneaAlertResponse
from ..types.grouped_stand_duration_response import GroupedStandDurationResponse
from ..types.grouped_stand_hour_response import GroupedStandHourResponse
from ..types.grouped_heart_rate_alert_response import GroupedHeartRateAlertResponse
from ..types.grouped_a_fib_burden_response import GroupedAFibBurdenResponse
from ..types.grouped_workout_duration_response import GroupedWorkoutDurationResponse
from ..types.grouped_vo_2_max_response import GroupedVo2MaxResponse
from ..types.grouped_stress_level_response import GroupedStressLevelResponse
from ..types.grouped_mindfulness_minutes_response import GroupedMindfulnessMinutesResponse
from ..types.grouped_caffeine_response import GroupedCaffeineResponse
from ..types.grouped_water_response import GroupedWaterResponse
from ..types.grouped_steps_response import GroupedStepsResponse
from ..types.grouped_floors_climbed_response import GroupedFloorsClimbedResponse
from ..types.grouped_distance_response import GroupedDistanceResponse
from ..types.grouped_calories_basal_response import GroupedCaloriesBasalResponse
from ..types.grouped_calories_active_response import GroupedCaloriesActiveResponse
from ..types.grouped_respiratory_rate_response import GroupedRespiratoryRateResponse
from ..types.grouped_note_response import GroupedNoteResponse
from ..types.grouped_insulin_injection_response import GroupedInsulinInjectionResponse
from ..types.grouped_ige_response import GroupedIgeResponse
from ..types.grouped_igg_response import GroupedIggResponse
from ..types.grouped_hypnogram_response import GroupedHypnogramResponse
from ..types.grouped_hrv_response import GroupedHrvResponse
from ..types.grouped_heart_rate_response import GroupedHeartRateResponse
from ..types.grouped_glucose_response import GroupedGlucoseResponse
from ..types.grouped_cholesterol_response import GroupedCholesterolResponse
from ..types.grouped_carbohydrates_response import GroupedCarbohydratesResponse
from ..types.grouped_body_temperature_delta_response import GroupedBodyTemperatureDeltaResponse
from ..types.grouped_body_temperature_response import GroupedBodyTemperatureResponse
from ..types.grouped_body_weight_response import GroupedBodyWeightResponse
from ..types.grouped_body_fat_response import GroupedBodyFatResponse
from ..types.grouped_blood_oxygen_response import GroupedBloodOxygenResponse
from ..types.grouped_electrocardiogram_voltage_response import GroupedElectrocardiogramVoltageResponse
from ..types.grouped_blood_pressure_response import GroupedBloodPressureResponse
from ..types.client_facing_vo_2_max_timeseries import ClientFacingVo2MaxTimeseries
from ..types.client_facing_stress_level_timeseries import ClientFacingStressLevelTimeseries
from ..types.client_facing_mindfulness_minutes_timeseries import ClientFacingMindfulnessMinutesTimeseries
from ..types.client_facing_caffeine_timeseries import ClientFacingCaffeineTimeseries
from ..types.client_facing_water_timeseries import ClientFacingWaterTimeseries
from ..types.client_facing_steps_timeseries import ClientFacingStepsTimeseries
from ..types.client_facing_floors_climbed_timeseries import ClientFacingFloorsClimbedTimeseries
from ..types.client_facing_distance_timeseries import ClientFacingDistanceTimeseries
from ..types.client_facing_calories_basal_timeseries import ClientFacingCaloriesBasalTimeseries
from ..types.client_facing_calories_active_timeseries import ClientFacingCaloriesActiveTimeseries
from ..types.client_facing_respiratory_rate_timeseries import ClientFacingRespiratoryRateTimeseries
from ..types.client_facing_ige_timeseries import ClientFacingIgeTimeseries
from ..types.client_facing_igg_timeseries import ClientFacingIggTimeseries
from ..types.client_facing_hypnogram_timeseries import ClientFacingHypnogramTimeseries
from ..types.client_facing_hrv_timeseries import ClientFacingHrvTimeseries
from ..types.client_facing_heart_rate_timeseries import ClientFacingHeartRateTimeseries
from ..types.client_facing_glucose_timeseries import ClientFacingGlucoseTimeseries
from ..types.client_facing_cholesterol_timeseries import ClientFacingCholesterolTimeseries
from ..types.client_facing_body_weight_timeseries import ClientFacingBodyWeightTimeseries
from ..types.client_facing_body_fat_timeseries import ClientFacingBodyFatTimeseries
from ..types.client_facing_blood_oxygen_timeseries import ClientFacingBloodOxygenTimeseries
from ..types.client_facing_electrocardiogram_voltage_timeseries import ClientFacingElectrocardiogramVoltageTimeseries
from ..types.client_facing_blood_pressure_timeseries import ClientFacingBloodPressureTimeseries
from ..core.client_wrapper import AsyncClientWrapper


class VitalsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def basal_body_temperature_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBasalBodyTemperatureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBasalBodyTemperatureResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.basal_body_temperature_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/basal_body_temperature/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBasalBodyTemperatureResponse,
                    parse_obj_as(
                        type_=GroupedBasalBodyTemperatureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def handwashing_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHandwashingResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHandwashingResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.handwashing_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/handwashing/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHandwashingResponse,
                    parse_obj_as(
                        type_=GroupedHandwashingResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def daylight_exposure_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedDaylightExposureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedDaylightExposureResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.daylight_exposure_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/daylight_exposure/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedDaylightExposureResponse,
                    parse_obj_as(
                        type_=GroupedDaylightExposureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def uv_exposure_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedUvExposureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedUvExposureResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.uv_exposure_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/uv_exposure/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedUvExposureResponse,
                    parse_obj_as(
                        type_=GroupedUvExposureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def fall_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedFallResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedFallResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.fall_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/fall/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedFallResponse,
                    parse_obj_as(
                        type_=GroupedFallResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def inhaler_usage_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedInhalerUsageResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedInhalerUsageResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.inhaler_usage_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/inhaler_usage/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedInhalerUsageResponse,
                    parse_obj_as(
                        type_=GroupedInhalerUsageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def peak_expiratory_flow_rate_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedPeakExpiratoryFlowRateResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedPeakExpiratoryFlowRateResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.peak_expiratory_flow_rate_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/peak_expiratory_flow_rate/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedPeakExpiratoryFlowRateResponse,
                    parse_obj_as(
                        type_=GroupedPeakExpiratoryFlowRateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def forced_vital_capacity_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedForcedVitalCapacityResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedForcedVitalCapacityResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.forced_vital_capacity_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/forced_vital_capacity/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedForcedVitalCapacityResponse,
                    parse_obj_as(
                        type_=GroupedForcedVitalCapacityResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def forced_expiratory_volume_1_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedForcedExpiratoryVolume1Response:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedForcedExpiratoryVolume1Response
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.forced_expiratory_volume_1_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/forced_expiratory_volume_1/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedForcedExpiratoryVolume1Response,
                    parse_obj_as(
                        type_=GroupedForcedExpiratoryVolume1Response,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def wheelchair_push_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedWheelchairPushResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedWheelchairPushResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.wheelchair_push_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/wheelchair_push/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedWheelchairPushResponse,
                    parse_obj_as(
                        type_=GroupedWheelchairPushResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sleep_breathing_disturbance_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedSleepBreathingDisturbanceResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedSleepBreathingDisturbanceResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.sleep_breathing_disturbance_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/sleep_breathing_disturbance/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedSleepBreathingDisturbanceResponse,
                    parse_obj_as(
                        type_=GroupedSleepBreathingDisturbanceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sleep_apnea_alert_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedSleepApneaAlertResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedSleepApneaAlertResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.sleep_apnea_alert_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/sleep_apnea_alert/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedSleepApneaAlertResponse,
                    parse_obj_as(
                        type_=GroupedSleepApneaAlertResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def stand_duration_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedStandDurationResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedStandDurationResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.stand_duration_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/stand_duration/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedStandDurationResponse,
                    parse_obj_as(
                        type_=GroupedStandDurationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def stand_hour_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedStandHourResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedStandHourResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.stand_hour_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/stand_hour/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedStandHourResponse,
                    parse_obj_as(
                        type_=GroupedStandHourResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def heart_rate_alert_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHeartRateAlertResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHeartRateAlertResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.heart_rate_alert_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/heart_rate_alert/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHeartRateAlertResponse,
                    parse_obj_as(
                        type_=GroupedHeartRateAlertResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def afib_burden_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedAFibBurdenResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedAFibBurdenResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.afib_burden_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/afib_burden/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedAFibBurdenResponse,
                    parse_obj_as(
                        type_=GroupedAFibBurdenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def workout_duration_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedWorkoutDurationResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedWorkoutDurationResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.workout_duration_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/workout_duration/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedWorkoutDurationResponse,
                    parse_obj_as(
                        type_=GroupedWorkoutDurationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def vo_2_max_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedVo2MaxResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedVo2MaxResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.vo_2_max_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/vo2_max/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedVo2MaxResponse,
                    parse_obj_as(
                        type_=GroupedVo2MaxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def stress_level_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedStressLevelResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedStressLevelResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.stress_level_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/stress_level/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedStressLevelResponse,
                    parse_obj_as(
                        type_=GroupedStressLevelResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def mindfulness_minutes_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedMindfulnessMinutesResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedMindfulnessMinutesResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.mindfulness_minutes_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/mindfulness_minutes/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedMindfulnessMinutesResponse,
                    parse_obj_as(
                        type_=GroupedMindfulnessMinutesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def caffeine_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCaffeineResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCaffeineResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.caffeine_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/caffeine/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCaffeineResponse,
                    parse_obj_as(
                        type_=GroupedCaffeineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def water_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedWaterResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedWaterResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.water_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/water/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedWaterResponse,
                    parse_obj_as(
                        type_=GroupedWaterResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def steps_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedStepsResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedStepsResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.steps_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/steps/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedStepsResponse,
                    parse_obj_as(
                        type_=GroupedStepsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def floors_climbed_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedFloorsClimbedResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedFloorsClimbedResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.floors_climbed_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/floors_climbed/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedFloorsClimbedResponse,
                    parse_obj_as(
                        type_=GroupedFloorsClimbedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def distance_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedDistanceResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedDistanceResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.distance_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/distance/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedDistanceResponse,
                    parse_obj_as(
                        type_=GroupedDistanceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def calories_basal_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCaloriesBasalResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCaloriesBasalResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.calories_basal_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/calories_basal/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCaloriesBasalResponse,
                    parse_obj_as(
                        type_=GroupedCaloriesBasalResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def calories_active_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCaloriesActiveResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCaloriesActiveResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.calories_active_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/calories_active/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCaloriesActiveResponse,
                    parse_obj_as(
                        type_=GroupedCaloriesActiveResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def respiratory_rate_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedRespiratoryRateResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedRespiratoryRateResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.respiratory_rate_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/respiratory_rate/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedRespiratoryRateResponse,
                    parse_obj_as(
                        type_=GroupedRespiratoryRateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def note_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedNoteResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedNoteResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.note_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/note/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedNoteResponse,
                    parse_obj_as(
                        type_=GroupedNoteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def insulin_injection_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedInsulinInjectionResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedInsulinInjectionResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.insulin_injection_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/insulin_injection/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedInsulinInjectionResponse,
                    parse_obj_as(
                        type_=GroupedInsulinInjectionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def ige_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedIgeResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedIgeResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.ige_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/ige/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedIgeResponse,
                    parse_obj_as(
                        type_=GroupedIgeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def igg_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedIggResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedIggResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.igg_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/igg/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedIggResponse,
                    parse_obj_as(
                        type_=GroupedIggResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def hypnogram_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHypnogramResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHypnogramResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.hypnogram_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/hypnogram/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHypnogramResponse,
                    parse_obj_as(
                        type_=GroupedHypnogramResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def hrv_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHrvResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHrvResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.hrv_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/hrv/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHrvResponse,
                    parse_obj_as(
                        type_=GroupedHrvResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def heartrate_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHeartRateResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHeartRateResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.heartrate_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/heartrate/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHeartRateResponse,
                    parse_obj_as(
                        type_=GroupedHeartRateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def glucose_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedGlucoseResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedGlucoseResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.glucose_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/glucose/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedGlucoseResponse,
                    parse_obj_as(
                        type_=GroupedGlucoseResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cholesterol_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCholesterolResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCholesterolResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.cholesterol_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCholesterolResponse,
                    parse_obj_as(
                        type_=GroupedCholesterolResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def carbohydrates_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCarbohydratesResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCarbohydratesResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.carbohydrates_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/carbohydrates/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCarbohydratesResponse,
                    parse_obj_as(
                        type_=GroupedCarbohydratesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def body_temperature_delta_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBodyTemperatureDeltaResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBodyTemperatureDeltaResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.body_temperature_delta_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_temperature_delta/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBodyTemperatureDeltaResponse,
                    parse_obj_as(
                        type_=GroupedBodyTemperatureDeltaResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def body_temperature_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBodyTemperatureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBodyTemperatureResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.body_temperature_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_temperature/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBodyTemperatureResponse,
                    parse_obj_as(
                        type_=GroupedBodyTemperatureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def body_weight_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBodyWeightResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBodyWeightResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.body_weight_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_weight/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBodyWeightResponse,
                    parse_obj_as(
                        type_=GroupedBodyWeightResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def body_fat_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBodyFatResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBodyFatResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.body_fat_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_fat/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBodyFatResponse,
                    parse_obj_as(
                        type_=GroupedBodyFatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def blood_oxygen_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBloodOxygenResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBloodOxygenResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.blood_oxygen_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/blood_oxygen/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBloodOxygenResponse,
                    parse_obj_as(
                        type_=GroupedBloodOxygenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def electrocardiogram_voltage_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedElectrocardiogramVoltageResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedElectrocardiogramVoltageResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.electrocardiogram_voltage_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/electrocardiogram_voltage/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedElectrocardiogramVoltageResponse,
                    parse_obj_as(
                        type_=GroupedElectrocardiogramVoltageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def blood_pressure_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBloodPressureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBloodPressureResponse
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.blood_pressure_grouped(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/blood_pressure/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBloodPressureResponse,
                    parse_obj_as(
                        type_=GroupedBloodPressureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def vo_2_max(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingVo2MaxTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingVo2MaxTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.vo_2_max(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/vo2_max",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingVo2MaxTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingVo2MaxTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def stress_level(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingStressLevelTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingStressLevelTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.stress_level(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/stress_level",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingStressLevelTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingStressLevelTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def mindfulness_minutes(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingMindfulnessMinutesTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingMindfulnessMinutesTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.mindfulness_minutes(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/mindfulness_minutes",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingMindfulnessMinutesTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingMindfulnessMinutesTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def caffeine(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCaffeineTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCaffeineTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.caffeine(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/caffeine",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCaffeineTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCaffeineTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def water(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingWaterTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingWaterTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.water(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/water",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingWaterTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingWaterTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def steps(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingStepsTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingStepsTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.steps(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/steps",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingStepsTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingStepsTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def floors_climbed(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingFloorsClimbedTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingFloorsClimbedTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.floors_climbed(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/floors_climbed",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingFloorsClimbedTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingFloorsClimbedTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def distance(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingDistanceTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingDistanceTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.distance(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/distance",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingDistanceTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingDistanceTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def calories_basal(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCaloriesBasalTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCaloriesBasalTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.calories_basal(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/calories_basal",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCaloriesBasalTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCaloriesBasalTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def calories_active(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCaloriesActiveTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCaloriesActiveTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.calories_active(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/calories_active",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCaloriesActiveTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCaloriesActiveTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def respiratory_rate(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingRespiratoryRateTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingRespiratoryRateTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.respiratory_rate(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/respiratory_rate",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingRespiratoryRateTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingRespiratoryRateTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def ige(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingIgeTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingIgeTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.ige(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/ige",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingIgeTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingIgeTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def igg(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingIggTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingIggTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.igg(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/igg",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingIggTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingIggTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def hypnogram(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingHypnogramTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingHypnogramTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.hypnogram(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/hypnogram",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingHypnogramTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingHypnogramTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def hrv(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingHrvTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingHrvTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.hrv(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/hrv",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingHrvTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingHrvTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def heartrate(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingHeartRateTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingHeartRateTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.heartrate(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/heartrate",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingHeartRateTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingHeartRateTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def glucose(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingGlucoseTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingGlucoseTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.glucose(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/glucose",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingGlucoseTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingGlucoseTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cholesterol_triglycerides(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.cholesterol_triglycerides(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/triglycerides",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cholesterol_total(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.cholesterol_total(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/total",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cholesterol_ldl(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.cholesterol_ldl(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/ldl",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cholesterol_hdl(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.cholesterol_hdl(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/hdl",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cholesterol(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.cholesterol(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def body_weight(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingBodyWeightTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingBodyWeightTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.body_weight(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_weight",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingBodyWeightTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingBodyWeightTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def body_fat(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingBodyFatTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingBodyFatTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.body_fat(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_fat",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingBodyFatTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingBodyFatTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def blood_oxygen(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingBloodOxygenTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingBloodOxygenTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.blood_oxygen(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/blood_oxygen",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingBloodOxygenTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingBloodOxygenTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def electrocardiogram_voltage(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingElectrocardiogramVoltageTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingElectrocardiogramVoltageTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.electrocardiogram_voltage(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/electrocardiogram_voltage",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingElectrocardiogramVoltageTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingElectrocardiogramVoltageTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def blood_pressure(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingBloodPressureTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingBloodPressureTimeseries]
            Successful Response

        Examples
        --------
        from vital import Vital

        client = Vital(
            api_key="YOUR_API_KEY",
        )
        client.vitals.blood_pressure(
            user_id="user_id",
            start_date="start_date",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/blood_pressure",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingBloodPressureTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingBloodPressureTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncVitalsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def basal_body_temperature_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBasalBodyTemperatureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBasalBodyTemperatureResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.basal_body_temperature_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/basal_body_temperature/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBasalBodyTemperatureResponse,
                    parse_obj_as(
                        type_=GroupedBasalBodyTemperatureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def handwashing_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHandwashingResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHandwashingResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.handwashing_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/handwashing/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHandwashingResponse,
                    parse_obj_as(
                        type_=GroupedHandwashingResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def daylight_exposure_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedDaylightExposureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedDaylightExposureResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.daylight_exposure_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/daylight_exposure/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedDaylightExposureResponse,
                    parse_obj_as(
                        type_=GroupedDaylightExposureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def uv_exposure_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedUvExposureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedUvExposureResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.uv_exposure_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/uv_exposure/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedUvExposureResponse,
                    parse_obj_as(
                        type_=GroupedUvExposureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def fall_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedFallResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedFallResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.fall_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/fall/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedFallResponse,
                    parse_obj_as(
                        type_=GroupedFallResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def inhaler_usage_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedInhalerUsageResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedInhalerUsageResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.inhaler_usage_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/inhaler_usage/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedInhalerUsageResponse,
                    parse_obj_as(
                        type_=GroupedInhalerUsageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def peak_expiratory_flow_rate_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedPeakExpiratoryFlowRateResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedPeakExpiratoryFlowRateResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.peak_expiratory_flow_rate_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/peak_expiratory_flow_rate/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedPeakExpiratoryFlowRateResponse,
                    parse_obj_as(
                        type_=GroupedPeakExpiratoryFlowRateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def forced_vital_capacity_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedForcedVitalCapacityResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedForcedVitalCapacityResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.forced_vital_capacity_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/forced_vital_capacity/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedForcedVitalCapacityResponse,
                    parse_obj_as(
                        type_=GroupedForcedVitalCapacityResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def forced_expiratory_volume_1_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedForcedExpiratoryVolume1Response:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedForcedExpiratoryVolume1Response
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.forced_expiratory_volume_1_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/forced_expiratory_volume_1/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedForcedExpiratoryVolume1Response,
                    parse_obj_as(
                        type_=GroupedForcedExpiratoryVolume1Response,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def wheelchair_push_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedWheelchairPushResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedWheelchairPushResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.wheelchair_push_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/wheelchair_push/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedWheelchairPushResponse,
                    parse_obj_as(
                        type_=GroupedWheelchairPushResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sleep_breathing_disturbance_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedSleepBreathingDisturbanceResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedSleepBreathingDisturbanceResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.sleep_breathing_disturbance_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/sleep_breathing_disturbance/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedSleepBreathingDisturbanceResponse,
                    parse_obj_as(
                        type_=GroupedSleepBreathingDisturbanceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sleep_apnea_alert_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedSleepApneaAlertResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedSleepApneaAlertResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.sleep_apnea_alert_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/sleep_apnea_alert/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedSleepApneaAlertResponse,
                    parse_obj_as(
                        type_=GroupedSleepApneaAlertResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stand_duration_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedStandDurationResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedStandDurationResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.stand_duration_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/stand_duration/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedStandDurationResponse,
                    parse_obj_as(
                        type_=GroupedStandDurationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stand_hour_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedStandHourResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedStandHourResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.stand_hour_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/stand_hour/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedStandHourResponse,
                    parse_obj_as(
                        type_=GroupedStandHourResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def heart_rate_alert_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHeartRateAlertResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHeartRateAlertResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.heart_rate_alert_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/heart_rate_alert/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHeartRateAlertResponse,
                    parse_obj_as(
                        type_=GroupedHeartRateAlertResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def afib_burden_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedAFibBurdenResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedAFibBurdenResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.afib_burden_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/afib_burden/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedAFibBurdenResponse,
                    parse_obj_as(
                        type_=GroupedAFibBurdenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def workout_duration_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedWorkoutDurationResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedWorkoutDurationResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.workout_duration_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/workout_duration/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedWorkoutDurationResponse,
                    parse_obj_as(
                        type_=GroupedWorkoutDurationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def vo_2_max_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedVo2MaxResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedVo2MaxResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.vo_2_max_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/vo2_max/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedVo2MaxResponse,
                    parse_obj_as(
                        type_=GroupedVo2MaxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stress_level_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedStressLevelResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedStressLevelResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.stress_level_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/stress_level/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedStressLevelResponse,
                    parse_obj_as(
                        type_=GroupedStressLevelResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def mindfulness_minutes_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedMindfulnessMinutesResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedMindfulnessMinutesResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.mindfulness_minutes_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/mindfulness_minutes/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedMindfulnessMinutesResponse,
                    parse_obj_as(
                        type_=GroupedMindfulnessMinutesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def caffeine_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCaffeineResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCaffeineResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.caffeine_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/caffeine/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCaffeineResponse,
                    parse_obj_as(
                        type_=GroupedCaffeineResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def water_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedWaterResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedWaterResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.water_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/water/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedWaterResponse,
                    parse_obj_as(
                        type_=GroupedWaterResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def steps_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedStepsResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedStepsResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.steps_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/steps/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedStepsResponse,
                    parse_obj_as(
                        type_=GroupedStepsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def floors_climbed_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedFloorsClimbedResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedFloorsClimbedResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.floors_climbed_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/floors_climbed/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedFloorsClimbedResponse,
                    parse_obj_as(
                        type_=GroupedFloorsClimbedResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def distance_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedDistanceResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedDistanceResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.distance_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/distance/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedDistanceResponse,
                    parse_obj_as(
                        type_=GroupedDistanceResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def calories_basal_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCaloriesBasalResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCaloriesBasalResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.calories_basal_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/calories_basal/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCaloriesBasalResponse,
                    parse_obj_as(
                        type_=GroupedCaloriesBasalResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def calories_active_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCaloriesActiveResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCaloriesActiveResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.calories_active_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/calories_active/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCaloriesActiveResponse,
                    parse_obj_as(
                        type_=GroupedCaloriesActiveResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def respiratory_rate_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedRespiratoryRateResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedRespiratoryRateResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.respiratory_rate_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/respiratory_rate/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedRespiratoryRateResponse,
                    parse_obj_as(
                        type_=GroupedRespiratoryRateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def note_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedNoteResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedNoteResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.note_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/note/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedNoteResponse,
                    parse_obj_as(
                        type_=GroupedNoteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def insulin_injection_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedInsulinInjectionResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedInsulinInjectionResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.insulin_injection_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/insulin_injection/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedInsulinInjectionResponse,
                    parse_obj_as(
                        type_=GroupedInsulinInjectionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def ige_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedIgeResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedIgeResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.ige_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/ige/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedIgeResponse,
                    parse_obj_as(
                        type_=GroupedIgeResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def igg_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedIggResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedIggResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.igg_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/igg/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedIggResponse,
                    parse_obj_as(
                        type_=GroupedIggResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def hypnogram_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHypnogramResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHypnogramResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.hypnogram_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/hypnogram/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHypnogramResponse,
                    parse_obj_as(
                        type_=GroupedHypnogramResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def hrv_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHrvResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHrvResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.hrv_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/hrv/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHrvResponse,
                    parse_obj_as(
                        type_=GroupedHrvResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def heartrate_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedHeartRateResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedHeartRateResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.heartrate_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/heartrate/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedHeartRateResponse,
                    parse_obj_as(
                        type_=GroupedHeartRateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def glucose_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedGlucoseResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedGlucoseResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.glucose_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/glucose/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedGlucoseResponse,
                    parse_obj_as(
                        type_=GroupedGlucoseResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cholesterol_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCholesterolResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCholesterolResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.cholesterol_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCholesterolResponse,
                    parse_obj_as(
                        type_=GroupedCholesterolResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def carbohydrates_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedCarbohydratesResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedCarbohydratesResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.carbohydrates_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/carbohydrates/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedCarbohydratesResponse,
                    parse_obj_as(
                        type_=GroupedCarbohydratesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def body_temperature_delta_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBodyTemperatureDeltaResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBodyTemperatureDeltaResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.body_temperature_delta_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_temperature_delta/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBodyTemperatureDeltaResponse,
                    parse_obj_as(
                        type_=GroupedBodyTemperatureDeltaResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def body_temperature_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBodyTemperatureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBodyTemperatureResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.body_temperature_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_temperature/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBodyTemperatureResponse,
                    parse_obj_as(
                        type_=GroupedBodyTemperatureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def body_weight_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBodyWeightResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBodyWeightResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.body_weight_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_weight/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBodyWeightResponse,
                    parse_obj_as(
                        type_=GroupedBodyWeightResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def body_fat_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBodyFatResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBodyFatResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.body_fat_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_fat/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBodyFatResponse,
                    parse_obj_as(
                        type_=GroupedBodyFatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def blood_oxygen_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBloodOxygenResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBloodOxygenResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.blood_oxygen_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/blood_oxygen/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBloodOxygenResponse,
                    parse_obj_as(
                        type_=GroupedBloodOxygenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def electrocardiogram_voltage_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedElectrocardiogramVoltageResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedElectrocardiogramVoltageResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.electrocardiogram_voltage_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/electrocardiogram_voltage/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedElectrocardiogramVoltageResponse,
                    parse_obj_as(
                        type_=GroupedElectrocardiogramVoltageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def blood_pressure_grouped(
        self,
        user_id: str,
        *,
        start_date: str,
        cursor: typing.Optional[str] = None,
        next_cursor: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GroupedBloodPressureResponse:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        next_cursor : typing.Optional[str]
            The cursor for fetching the next page, or `null` to fetch the first page.

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GroupedBloodPressureResponse
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.blood_pressure_grouped(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/blood_pressure/grouped",
            method="GET",
            params={
                "cursor": cursor,
                "next_cursor": next_cursor,
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GroupedBloodPressureResponse,
                    parse_obj_as(
                        type_=GroupedBloodPressureResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def vo_2_max(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingVo2MaxTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingVo2MaxTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.vo_2_max(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/vo2_max",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingVo2MaxTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingVo2MaxTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stress_level(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingStressLevelTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingStressLevelTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.stress_level(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/stress_level",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingStressLevelTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingStressLevelTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def mindfulness_minutes(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingMindfulnessMinutesTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingMindfulnessMinutesTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.mindfulness_minutes(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/mindfulness_minutes",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingMindfulnessMinutesTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingMindfulnessMinutesTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def caffeine(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCaffeineTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCaffeineTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.caffeine(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/caffeine",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCaffeineTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCaffeineTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def water(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingWaterTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingWaterTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.water(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/water",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingWaterTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingWaterTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def steps(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingStepsTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingStepsTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.steps(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/steps",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingStepsTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingStepsTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def floors_climbed(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingFloorsClimbedTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingFloorsClimbedTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.floors_climbed(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/floors_climbed",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingFloorsClimbedTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingFloorsClimbedTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def distance(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingDistanceTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingDistanceTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.distance(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/distance",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingDistanceTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingDistanceTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def calories_basal(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCaloriesBasalTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCaloriesBasalTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.calories_basal(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/calories_basal",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCaloriesBasalTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCaloriesBasalTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def calories_active(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCaloriesActiveTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCaloriesActiveTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.calories_active(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/calories_active",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCaloriesActiveTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCaloriesActiveTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def respiratory_rate(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingRespiratoryRateTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingRespiratoryRateTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.respiratory_rate(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/respiratory_rate",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingRespiratoryRateTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingRespiratoryRateTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def ige(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingIgeTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingIgeTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.ige(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/ige",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingIgeTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingIgeTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def igg(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingIggTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingIggTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.igg(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/igg",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingIggTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingIggTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def hypnogram(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingHypnogramTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingHypnogramTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.hypnogram(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/hypnogram",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingHypnogramTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingHypnogramTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def hrv(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingHrvTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingHrvTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.hrv(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/hrv",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingHrvTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingHrvTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def heartrate(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingHeartRateTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingHeartRateTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.heartrate(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/heartrate",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingHeartRateTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingHeartRateTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def glucose(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingGlucoseTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingGlucoseTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.glucose(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/glucose",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingGlucoseTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingGlucoseTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cholesterol_triglycerides(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.cholesterol_triglycerides(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/triglycerides",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cholesterol_total(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.cholesterol_total(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/total",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cholesterol_ldl(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.cholesterol_ldl(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/ldl",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cholesterol_hdl(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.cholesterol_hdl(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol/hdl",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cholesterol(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingCholesterolTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingCholesterolTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.cholesterol(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/cholesterol",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingCholesterolTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingCholesterolTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def body_weight(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingBodyWeightTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingBodyWeightTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.body_weight(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_weight",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingBodyWeightTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingBodyWeightTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def body_fat(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingBodyFatTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingBodyFatTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.body_fat(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/body_fat",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingBodyFatTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingBodyFatTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def blood_oxygen(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingBloodOxygenTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingBloodOxygenTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.blood_oxygen(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/blood_oxygen",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingBloodOxygenTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingBloodOxygenTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def electrocardiogram_voltage(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingElectrocardiogramVoltageTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingElectrocardiogramVoltageTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.electrocardiogram_voltage(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/electrocardiogram_voltage",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingElectrocardiogramVoltageTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingElectrocardiogramVoltageTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def blood_pressure(
        self,
        user_id: str,
        *,
        start_date: str,
        provider: typing.Optional[str] = None,
        end_date: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[ClientFacingBloodPressureTimeseries]:
        """
        Parameters
        ----------
        user_id : str

        start_date : str
            Date from in YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 00:00:00

        provider : typing.Optional[str]
            Provider oura/strava etc

        end_date : typing.Optional[str]
            Date to YYYY-MM-DD or ISO formatted date time. If a date is provided without a time, the time will be set to 23:59:59

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ClientFacingBloodPressureTimeseries]
            Successful Response

        Examples
        --------
        import asyncio

        from vital import AsyncVital

        client = AsyncVital(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.vitals.blood_pressure(
                user_id="user_id",
                start_date="start_date",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/timeseries/{jsonable_encoder(user_id)}/blood_pressure",
            method="GET",
            params={
                "provider": provider,
                "start_date": start_date,
                "end_date": end_date,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ClientFacingBloodPressureTimeseries],
                    parse_obj_as(
                        type_=typing.List[ClientFacingBloodPressureTimeseries],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
